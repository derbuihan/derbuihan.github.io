<!doctype html><html lang=en dir=auto><head><meta name=generator content="Hugo 0.120.4"><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>derbuihan blog</title>
<meta name=keywords content="Blog,Portfolio,PaperMod"><meta name=description content="ExampleSite description"><meta name=author content="derbuihan"><link rel=canonical href=https://derbuihan.github.io/><link crossorigin=anonymous href=/assets/css/stylesheet.5cfc680b1eeaeef9efbced92d46c2a9e876b72ee14fba85846afc4cff9e6e6f8.css integrity="sha256-XPxoCx7q7vnvvO2S1Gwqnodrcu4U+6hYRq/Ez/nm5vg=" rel="preload stylesheet" as=style><link rel=icon href=https://derbuihan.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://derbuihan.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://derbuihan.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://derbuihan.github.io/apple-touch-icon.png><link rel=mask-icon href=https://derbuihan.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://derbuihan.github.io/index.xml><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="derbuihan blog"><meta property="og:description" content="ExampleSite description"><meta property="og:type" content="website"><meta property="og:url" content="https://derbuihan.github.io/"><meta property="og:image" content="https://derbuihan.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="og:site_name" content="ExampleSite"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://derbuihan.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="derbuihan blog"><meta name=twitter:description content="ExampleSite description"><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"derbuihan blog","url":"https://derbuihan.github.io/","description":"ExampleSite description","thumbnailUrl":"https://derbuihan.github.io/favicon.ico","sameAs":["https://twitter.com/derbuihan/","https://github.com/derbuihan/"]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://derbuihan.github.io/ accesskey=h title="derbuihan blog (Alt + H)"><img src=https://derbuihan.github.io/apple-touch-icon.png alt aria-label=logo height=35>derbuihan blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://derbuihan.github.io/about/ title=About><span>About</span></a></li><li><a href=https://derbuihan.github.io/works/ title=Works><span>Works</span></a></li><li><a href=https://derbuihan.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class="first-entry home-info"><header class=entry-header><h1>blog</h1></header><div class=entry-content></div><footer class=entry-footer><div class=social-icons><a href=https://twitter.com/derbuihan/ target=_blank rel="noopener noreferrer me" title=Twitter><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M23 3a10.9 10.9.0 01-3.14 1.53 4.48 4.48.0 00-7.86 3v1A10.66 10.66.0 013 4s-4 9 5 13a11.64 11.64.0 01-7 2c9 5 20 0 20-11.5a4.5 4.5.0 00-.08-.83A7.72 7.72.0 0023 3z"/></svg></a><a href=https://github.com/derbuihan/ target=_blank rel="noopener noreferrer me" title=Github><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a></div></footer></article><article class=post-entry><header class=entry-header><h2>「ブルシット・ジョブ」を読んだ</h2></header><div class=entry-content><p>はじめに デヴィッド・グレーバー「ブルシット・ジョブ――クソどうでもいい仕事の理論」を読んだ。
デヴィッド・グレーバーの前作「官僚制のユートピア」を読んで1面白かったので、次作の「ブルシット・ジョブ」を手に取った。 結構有名な本らしい。
序 ブルシット・ジョブ現象について メモ この本は「社会は無益な仕事であふれかえっている」という著者の直感を確かめることから始まる。 「ブルシット・ジョブ現象について」という記事を雑誌に書いて、著者はその直感を世に示した。 この記事を書いたことで、様々な分野から自身の仕事がブルシットであるというメッセージが寄せられた。 これによって、著者は無益である仕事が社会に溢れかえっていることを確信し、その思考を発展させてこの本にまとめた。
感想 本の書き出しとしてすごく面白い。 人間の思考とは直感から始まるので、こういう書き出しは楽しく読める。 論文もこういう感じで書いてくれたらいいのに。
1 ブルシット・ジョブとはなにか？ メモ この章では、「ブルシット・ジョブ」について定義づけを行っている。 軍隊の部屋の引っ越しや美容師やマフィアの殺し屋などいくつかの仕事を例に挙げて、それらの仕事がブルシットかどうかを判断し、ブルシット・ジョブの定義を行っている。
「ブルシット・ジョブとは、被雇用者本人でさえ、その存在を正当化しがたいほど、完璧に無意味で、不必要で、有害でもある有償の雇用の形態である。とはいえ、その雇用条件の一環として、本人は、そうではないと取り繕わなければならないように感じている。」
感想 それぞれの働き手の主観によって定義づけするのが良くないみたいな議論があった。社会学だとそういうもんなのかな。
2 どんな種類のブルシット・ジョブがあるのか？ メモ この章ではブルシット・ジョブの分類を行っている。 ブルシット・ジョブを「取り巻き」、「脅し屋」、「尻ぬぐい」、「書類穴埋め人」、「タスクマスター」に分類している。
「取り巻き」：誰かを偉そうに見せたり、偉そうな気分を味合わせるという、ただそれだけのために存在している仕事。 例としてブローカーの代理で電話をかけるためだけに雇われている人を紹介している。 この人は「〇〇さんの代理としてお電話差し上げました。」っていうことで〇〇さんを偉そうに見せるのが仕事らしい。
「脅し屋」：その仕事が脅迫的な要素を持っている人間たち。 例として、化粧品の CM に出ている女優の映像を加工をする仕事を上げている。 映像の加工という仕事は、昔は映画の宇宙船をリアルに見せて、それを観客に見せて感動させるのが仕事だった。 ただ現在は女優の顔のシミを飛ばして肌を真っ白にして、それを CM として流してテレビの前の人の肌に欠陥があるように思わせるのが仕事である。 これも脅し屋に分類される。 他にもコールセンターで営業電話をする仕事に一部も脅し屋に分類している。
「尻ぬぐい」：組織に欠陥が存在しているためにその仕事が存在してるにすぎない雇われ人である。 例として、大学で部屋の工事を頼んだのに大工は来なくて大工が来ないことを謝る人がきたという著者の経験を述べている。 この謝だけの人を尻ぬぐいと呼んでいる。 謝る人を雇わずに大工を雇えばいいのではないかと書かれている。
「書類穴埋め人」：組織が実際にやっていないことをやっていると主張できるようにすることが主要ないし唯一の存在理由であるような仕事である。 例として海外の企業が不正な取引を実施していないかを調査する信用調査会社を上げている。 この信用調査会社は実際にはネットで 1 時間や 2 時間調べた内容を、専門用語をたくさん使って報告書を書くことで成り立っている。 実際にはほとんど企業の調査などしていないが、調査していると主張できるようにするから書類穴埋め人に分類される。
「タスクマスター」：タスクマスターは二つに分類される。 第一類型は、他人への仕事の割り当てだけからなる仕事である。これは取り巻きの亜種として分類しても良い。 第二類型は、ブルシットジョブをしている人を監視して、新たなブルシットジョブを作り出す仕事である。 例は長いので省略。
二次的ブルシットジョブとは、ブルシットジョブで成り立っている会社のビルの清掃や電気工事を請け負う雇用形態のことである。 この仕事そのものは清掃員や電気工事士であるためブルシットジョブには分類されていないが、そもそもブルシットジョブで成り立っている会社が存在しなければ、清掃員や電気工事士は雇われないため、二次的ブルシットジョブと呼ばれる。
感想 ブルシット・ジョブの分類をみた。 生活してると身の回りのかなりの割合がブルシットジョブに分類されている気がしてくる。 CM は半分ぐらい脅し屋だし、やってる感を出すための書類穴埋め人や、何もしてないタスクマスターも見られる。 むしろ現代社会ではブルシットジョブでない仕事をすることのほうが難しいのではないか。
3 なぜ、ブルシット・ジョブをしている人間は、きまって自分が不幸だと述べるのか？ メモ この章ではがツライ理由について述べる。
大学時代のアルバイト経験で、仕事を効率的に終わらせすぎて、時間が余ってしまった経験を述べる。 仕事が終わったため休んでいたら、雇用主に見つかってひどく怒られたと述べる。...</p></div><footer class=entry-footer><span title='2023-11-06 02:05:18 +0900 JST'>November 6, 2023</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;165 words&nbsp;·&nbsp;derbuihan</footer><a class=entry-link aria-label="post link to 「ブルシット・ジョブ」を読んだ" href=https://derbuihan.github.io/posts/bullshit_jobs/></a></article><article class=post-entry><header class=entry-header><h2>「Ｃプログラミング診断室」を読んだ</h2></header><div class=entry-content><p>はじめに 最近 C コンパイラを自作していて、ソフトウェア開発の歴史に興味が湧いている。 その中で昔のソフトウェア開発の現場を少しでも感じたくてこの本を読んだ。
この本は 1991 年から 1993 年にかけてソフトウェアデザインに掲載された記事をまとめたものである。 1989 年に C 言語の最初の標準化（ANSI 標準）が行われたので、それから 2~4 年経った時期に書かれた文章である。
1980 年代は BASIC が主流で、1990 年代になって UNIX の発展に伴って C 言語が流行り始めた理解している。 そのため 1990 年代前半は BASIC 時代の GOTO 文を多用してグローバル変数に状態を撒き散らすおじさんが、 C 言語を書き始めたという時期なのかなと思っている。 そういう時代背景から、こういった企画が立ち上がったのだろう。（ほとんど想像です。）
内容全体はこちらから無料で読むことができる。私は図書館で借りて読んだ。
メモ この本の面白さは、ソフトウェア開発において気をつけるべきことが書いてあることではなく著者の愚痴が書いてあることにあるが、それはさておき、この本を読んで今後意識したいことを忘れないように纏めておく。
変数名は省略しない 変数名を一文字にしない。 英語でもローマ字でもかまわないから、フルスペルに近いものにする。
関数は短く 関数は 60 行以内に。100 行を超えたら必ず分割。 理由は長い関数はパソコンの画面に収まらないから。
設計とは この本は徹底的にフローチャートによる設計を批判している。
goto 文と同様に諸悪の根源とされているフローチャートを業務に使っている職場 が存在していたとは恐ろしいことです。
フローチャートは、「ソフトウェア考古学」の対象であり、情報処理技術者 試験の中にだけ今だに残っているものです。
私の感覚ではフローチャートって実質的 GOTO 文だし、現代の安全なプログラミング言語とは全く合わないと思う。
設計技法、開発技法の本はいっぱい出版されています。フローチャート以外の方法について、概略で十分ですから、何か適当な本を読んでおくことは重要です。
設計とは、目的の処理をどうやって実現するか、どう関数に分解するかなどの「意図」や「全体 の流れ」を書きあげるものです。
設計の表現方法は複数ある。設計は所詮人間同士のコミュニケーション手段なのだから、伝わらない設計を作るより伝わる設計を作るべきだと思う。
データ構造を書く データ構造はしっかり書くべきだと言っている。
プログラムは、データを処理するためにあり、データの違いによって制御の流れ が変更されます。あくまでも、データが主体です。変数、引数などのデータをどう定義するかで、 プログラムの組易さは大幅に改良されます。データ構造がどうなっているかの図の方が、フローチャー トよりはるかに役立ちます。データの意味だけはしっかり書きましょう。
大抵のプログラムは逆アセンブルすると mov 命令が最も多く使われているし、コンピュータとはデータを処理する機械らしい。...</p></div><footer class=entry-footer><span title='2023-11-02 19:32:18 +0900 JST'>November 2, 2023</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;97 words&nbsp;·&nbsp;derbuihan</footer><a class=entry-link aria-label="post link to 「Ｃプログラミング診断室」を読んだ" href=https://derbuihan.github.io/posts/c_programming_diagnosis_room/></a></article><article class=post-entry><header class=entry-header><h2>「官僚制のユートピア」を読んだ</h2></header><div class=entry-content><p>はじめに デヴィッド・グレーバー「僚制のユートピア　テクノロジー、構造的愚かさ、リベラリズムの鉄則」を読んだ。
これまでこのブログでは IT 技術関連の記事を書いてきたが、最近はZennで書くようになったので、これからはZennに書くのには適さない記事を書いていこうと思う。
はじめにこの本を読むに至った経緯から説明する。私は数学とか物理とかプログラムが好きな人間で、理路整然と並んだ定理や原理を大切にし、プログラムで自動化された仕組みを作るのが好きな人間である。（もちろん申請書類を書くのは大嫌いだが。。。） 最近は、ChatGPT をはじめとする生成系 AI を試していて、この技術がどういった方向に向かっていくのか気にしている。 生成系 AI が社会どのように変えていくのか、ヒントが得られる気がしてこの本を手に取った。
各章を読んでメモと感想を書いて、最後に全体の感想を書く。
序　リベラリズムの鉄則 メモ アメリカの政治の歴史とアメリカの政府と金融と企業が一体となっている。 そもそも金融とは国が戦争のために作ったもので、金融そのものが規制の塊みたいなものなのだから、市場の自由な競争に任せれば規制が全てなくなるというのは幻想で、市場とはそもそも官僚的なシステムそのものである。 そのため、そもそも市場に任せれば効率化されるのではなく、逆に規制が増えて規制が正しく働いているか監視するための役所の仕事と人が増えて全体として非効率になる。 この構造は社会のありとあらゆる場所で観測できるので、それをリベラリズムの鉄則と呼んでいる。
リベラルな人が規制緩和を掲げて選挙に出るが、それはその人が得する形に規制を変更するだけで、それによって手続きが減ることはなく、逆に手続きが増える結果になっている。 例えば大学の研究においては、競争的資金獲得のために研究者は大量の書類を書かなければならなくなった。
官僚制は政府と金融だけでなく、企業や教育や医療などが一体となって、一つの大きな官僚システムを構築している。 例えば、アメリカは仕組みとして大卒でないと企業に入れなくなったので、学生は大学を卒業するために金融機関から多額のお金を借りて借金をするような仕組みになっている。 なので学生は借金のために大量に書類を書くというお役所仕事に邁進する羽目になっている。 また、それでお金を借りたら企業に入って収入を監視されながら働き、その収入の一部を銀行に納め続けるシステムが出来上がっている。 これは社会全体として官僚システムを構築したことの一つの例である。
金融市場が発展するにつれて、市内には銀行の支店が増え続けた。 銀行の支店には銃を持った警備員とパソコンがある。 これは暴力と規則が一つになっており、官僚制の象徴そのものである。
感想 日本の右翼と左翼は逆転してる？からか混乱して、アメリカの政治の部分はよくわからなかった。 リベラルな人たちが規制緩和を掲げるが、結果として規制が増えて書類が増えるというのは日本でも同じだなぁと思った。 制度の変更って制度を作る人が得する形で変更するから、そうなると弱い立場の人が報告書類を大量に作らなきゃならなくなるのは当然な気がする。 研究とかね。
自由な市場競争の合理性は幻想であるというのは、新たな気づきだった。 農業のような儲からない仕事は価値がないから先進国で高度な教育を受けた人がやるのは勿体無いよね。 だから貿易を自由化して輸入しましょう。 って例だけを聞いて市場経済の合理性について納得してたが、そもそも貿易するには大量の制度と警察と役所の仕事が必要なので、それをゼロとして見積もって市場の自由は全体として効率的を論じるのは間違ってる気がした。 実際、グローバル化とともに書類が増えてるわけだし。
1 想像力の死角 メモ 母親が病気になった際に後見人と銀行をたらい回しになった。 官僚制における書類作成は複雑すぎてもう誰の手にも追えない状況になっている。 現代のペーパーワークはつまらないものとして規定されている。 現代の出生届は非常に無機質なものだが、昔の出生届は豪華な装飾がおこなわれていた。 もっとも自由と言われている大学人も現在では官僚である。 大学人も休憩室で会話する際には自信の研究について語るのではなく、自分が普段やっているペーパーワークについて語る。
あらゆる官僚的手続きは全て構造的暴力に基礎付けられている。 一つ例を挙げると、アフリカのアパルトヘイトはでは、労働者に様々な個人情報が記載された単一の ID カードを配布していた。そのカードは「ばかパス」と呼ばれていた。 これはそもそも構造的暴力が官僚的手続きを作った愚かな例である。
構造的暴力は解釈労働をうむ。 解釈労働とは相手の考えに思いを巡らせることである。 フェミニズムを例にすると、男性が女性の考えに思いを巡らせる時間は、女性が男性の考えに思いを巡らせる時間よりも圧倒的に短い。 それは、女性は男性による構造的暴力の被害者であるから、女性は男性の考えを理解するために解釈労働を行うのである。
構造的暴力の加害者側は、自身の立ち位置が崩れるのを嫌う。 警察官を例にすると、警察官は普段はペーパーワークをしているが、免許証持ってない人が運転してて逃げた場合とか、逮捕しようとしてるのに抵抗する人に対して暴力的になる。 それは官僚システムの中で自分の役割が危うくなるから。
感想 官僚制の中では誰しもが構造的暴力の加害者になってしまうことがある。 そうなると自分はあまり意識していない人（構造的暴力の被害者）に良く観察されることになる。 私はこの記事を思い出した。 携帯電話のアプリ開発を軍隊に例えて面白くした記事だが、非常によく書けていると思う。 確かに、この記事の人物たちも官僚的なやり方でアプリの開発をしているし、その上で自身は構造的の被害者なので加害者側をよく観察している。 高度に官僚化された組織において上司というのは構造的暴力の加害者になりやすいので、部下に対して解釈労働を払う方が良いのかもね。...</p></div><footer class=entry-footer><span title='2023-10-04 00:19:16 +0900 JST'>October 4, 2023</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;159 words&nbsp;·&nbsp;derbuihan</footer><a class=entry-link aria-label="post link to 「官僚制のユートピア」を読んだ" href=https://derbuihan.github.io/posts/the_utopia_of_rules/></a></article><article class=post-entry><header class=entry-header><h2>Proof-Generalを用いたCoqの環境構築</h2></header><div class=entry-content><p>はじめに 久々に Coq で遊びたくなったので、M1 Mac にインストールしてみた。 最近の Coq は VSCode で書くのが主流？らしいが、今回は Emacs + Proof-General で環境構築を行う。
環境構築の方法 基本的にbrewやmelpaなどの package 管理システムになるべく依存した形で環境構築を行う。
はじめに、Coqのインストール(–build-from-source をつけないとcoqtop実行時にエラーが出た。)
brew install coq --build-from-source GUI 版 Emacs のインストール
brew install emacs --cask Emacs の設定 次は Emacs の設定を行う。 Emacs の設定ファイルは~/.emacs.d/init.elに記載する。
まずはmelpa(Emacs のプラグインのパッケージマネージャー)のセットアップを行う。 ~/.emacs.d/init.elに以下を記載し、
(require 'package) (let* ((no-ssl (and (memq system-type '(windows-nt ms-dos)) (not (gnutls-available-p)))) (proto (if no-ssl "http" "https"))) (add-to-list 'package-archives (cons "melpa" (concat proto "://melpa.org/packages/")) t)) (package-initialize) emacs を起動して...</p></div><footer class=entry-footer><span title='2022-10-23 03:53:00 +0900 JST'>October 23, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;200 words&nbsp;·&nbsp;derbuihan</footer><a class=entry-link aria-label="post link to Proof-Generalを用いたCoqの環境構築" href=https://derbuihan.github.io/posts/coq_install/></a></article><article class=post-entry><header class=entry-header><h2>Linuxカーネルを書き換えてTCPの再送時間のパレート最適性を裏切る方法 〜Android編〜</h2></header><div class=entry-content><p>はじめに Linux カーネルを書き換えて TCP の再送時間のパレート最適性を裏切る方法はこの記事で実験を行った。 ただ私のような Mac ユーザーは Linux をサーバー用途でしか使わないため、カーネルを書き換えたところでそこまで得できない。 やはりこれを使うにはクライアント端末で Kernel を書き換える方が楽しい。 私が普段使ってるクライアント端末で Kernel を書き換えられそうなもの、そう Android である。 この記事では自分の持ってるスマホに、私が書き換えた kernel をインストールして実験してみる。 （この記事はただの検証記事であり TCP のプロトコルを裏切ることを推奨するものではありません。私も書き換えたカーネルを普段使いしているわけではありません。）
Android をソースからビルドする方法 この記事では PixelExperience という Android の Custom firmware のビルド方法を紹介する。 ビルドに用いたマシンは、OS: Ubuntu 22.04 LTS, メモリ: 16GB (+ Swap 32GB)である。 以下の内容は、この記事を参考にした。
fastboot や adb や git や python をインストールする。
sudo apt install android-sdk git python-is-python3 android をビルドするための依存関係全部インストールするスクリプト実行する。
git clone https://github.com/akhilnarang/scripts cd scripts ./setup/android_build_env.sh ビルド用のディレクトリを作る。
mkdir -p ~/android/pe git の設定を作る。（すでにやってたら必要なし）...</p></div><footer class=entry-footer><span title='2022-10-21 23:42:59 +0900 JST'>October 21, 2022</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;317 words&nbsp;·&nbsp;derbuihan</footer><a class=entry-link aria-label="post link to Linuxカーネルを書き換えてTCPの再送時間のパレート最適性を裏切る方法 〜Android編〜" href=https://derbuihan.github.io/posts/android_tcp_rto_hack/></a></article><article class=post-entry><header class=entry-header><h2>elmとBootstrapやTailwind CSSを組み合わせて簡単なWebサービスを開発する方法</h2></header><div class=entry-content><p>はじめに 私はブラウザ上で動く簡単なアプリを作る際にelmを用いることが多い。 elmはブラウザの状態とユーザーの入力を言語の機能とそのアーキテクチャで簡単に管理できるため、簡単なアプリであればほとんど迷うことがなく作りたいものが作れる点で気にいっている。 ただ最近では、elmの便利な状態管理の手法は JS のフレームワークにも導入され、React のコンポーネントを用いた UI 開発や JS のその他の資源と組み合わせることで効率的にフロントエンドを開発することが主流になってきている。 このような流れのためか、ここ数年はelmを用いた開発を行う人が極端に少なくなってきていると感じている。 ただフロントエンドの専門家ではない私からすると、フレームワークの選定に迷う必要がない点や、tsにするかjsにするか迷わなくて良い点や、Haskellライクな言語の楽さとelm-formatの利便性などの観点から考えると、簡単な Web アプリであれば依然としてelmを用いて開発を行うことは悪くない選択肢だと思っている。 この記事ではelmとBootstrapやelmとTailwind CSSを組み合わせたサンプルアプリの構築方法を解説する。
環境構築(Bootstrap 編) プロジェクトを作成
$ mkdir elm-bootstrap-sampleapp $ cd elm-bootstrap-sampleapp $ npm init -y bootstrap をインストール（参考）
$ npm i --save-dev parcel $ npm i --save-dev bootstrap @popperjs/core elm をインストールして環境を構築
$ npm i --save-dev elm @parcel/transformer-elm $ npx elm init 必要なファイルを作成
$ touch src/index.html src/index.js src/index.scss src/Main.elm src/index.htmlを書く。
&lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset="UTF-8" /> &lt;meta name="viewport" content="width=device-width, initial-scale=1....</p></div><footer class=entry-footer><span title='2022-10-17 02:12:49 +0900 JST'>October 17, 2022</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;568 words&nbsp;·&nbsp;derbuihan</footer><a class=entry-link aria-label="post link to elmとBootstrapやTailwind CSSを組み合わせて簡単なWebサービスを開発する方法" href=https://derbuihan.github.io/posts/elm_sampleapp/></a></article><article class=post-entry><header class=entry-header><h2>Linuxカーネルを書き換えてTCPの再送時間のパレート最適性を裏切る方法</h2></header><div class=entry-content><p>はじめに インターネットには多数のデバイスが存在しており、その多数のデバイスが通信し合うために通信プロトコルが定義されている。 様々な通信プロトコルを勉強していくと、ネットワーク内の通信が正常に行えるためにはそのネットワークの参加者全員が通信プロトコルを守っていることが必要になることに気がつく。
たとえば、TCP の通信が失敗したときの再送の間隔について説明する。 今回はわかりやすく普通のサーバー・クライアントモデルの Web サービスを考え、サーバー対してクライアントから大量のアクセスが集まりそのリソースが枯渇した状況を考える。 サーバーはリソースの枯渇により全てのクライアントと TCP のコネクションを張れないことから、一部クライアントからのアクセスを拒否する。 拒否されたクライアントは再度サーバーに対してアクセスしようと試みる。 これをアクセス出来るまでクライアントは繰り返すわけだが、その間隔は実は一定ではない。 最初は 1 秒程度で素早く再送するが、サーバーが何度もアクセスを拒否すると、クライアントの方で自動で再送の間隔を指数関数的に伸ばしてアクセスするようになっている。 このような仕様になってる理由は、全員が間隔を開けずに即座に繰り返し通信を試みた場合はサーバーのリソースは一生枯渇したままで回復しない可能性があるためである。 一方でクライアント側で指数関数的に間隔を伸ばしていくと、サーバーがアクセスを拒否し続ければいつかはリソースが回復し少しクライアントの通信を捌けるようになる。 そのため、TCP ではアクセスに失敗したときクライアント側で再送する間隔を指数関数的に引き伸ばしていくというプロトコルになっているのである。
ここで注目したいのが、TCP の再送間隔の調整はクライアントで行われるという点である。 再送の間隔を極端に短くして再度送信するようなデバイスを作ったとしたら、そのデバイスはネットワークの中で唯一得することが出来るのである。 囚人のジレンマの言葉で言えば、現在のネットワークは全員が黙秘しているパレート最適な状態であるから、自分だけ自白することで自分だけの利得を最大化出来るのである。 (世界中の数百億台というディバイスでパレート最適な状態を保っているというのは考え深いものがある。) このようなインターネットのプロトコルのパレート最適性を裏切る方法は TCP の再送時間以外にも探せばいくつもあるだろう。 この記事では TCP の再送間隔について Linux カーネルを弄って実験をする。
実験条件 OS: Ubuntu 22.04.1 LTS Linux kernel version: 5.15.73
Server と Client の IP アドレスは
Server: 192.168.0.10 Client: 192.168.0.20 とする。
TCP がアクセスを再試行する回数は/etc/sysctl.conf内に、
net.ipv4.tcp_syn_retries = 5 を書くことで調整が可能である。（この場合は 5 回リトライする）
つぎに、TCP の再送時間の計測方法を説明する。 まず Server で 23 番の TCP ポートを塞ぐ。 クライアント側で Server に telnet でアクセスを行う。...</p></div><footer class=entry-footer><span title='2022-09-16 21:12:37 +0900 JST'>September 16, 2022</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;228 words&nbsp;·&nbsp;derbuihan</footer><a class=entry-link aria-label="post link to Linuxカーネルを書き換えてTCPの再送時間のパレート最適性を裏切る方法" href=https://derbuihan.github.io/posts/linux_tcp_rto_hack/></a></article><article class=post-entry><header class=entry-header><h2>Digest認証の仕組みをBashとJavaScriptで理解したい。</h2></header><div class=entry-content><p>Basic 認証や Digest 認証をゼロから実装する機会があったのでその仕組をメモしておく。 本記事の node はすべて v18 である。
Basic 認証と Digest 認証 Basic 認証 はじめに Basic 認証の仕組みにを解説する。
Basic 認証においてクライアントが初めて http リクエストを送ったときは、Status Code が401 Unauthorizedでヘッダーに
www-authenticate: Basic realm="secure" が付与されたレスポンスがサーバーから帰ってくる。 ちなみに realm は認証領域を表す。
クライアントがユーザーとパスワードを user:pass のように入力したときは
Authorization: Basic dXNlcjpwYXNz を付与してレスポンスを返す仕組みになっている。 このような動作は Basic 認証を用いたサイトに Chrome で接続し、デベロッパーツールで通信を監視することで確かめることが出来る。
次に、dXNlcjpwYXNzの計算方法について確認しておく。 結論から言うとdXNlcjpwYXNzはuser:passを base64 でエンコードしたものである。 Bash では
$ echo -n "user:pass" | base64 dXNlcjpwYXNz JavaScript では
> btoa("user:pass") 'dXNlcjpwYXNz' のように計算出来る。
ただ、Base64 はハッシュ関数でもなんでもなくて文字列を単純な方法で変換しているだけなので、簡単に戻すことが出来る。 Bash では
❯ echo -n "dXNlcjpwYXNz" | base64 -d user:pass JavaScript では...</p></div><footer class=entry-footer><span title='2022-07-13 00:27:26 +0900 JST'>July 13, 2022</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;703 words&nbsp;·&nbsp;derbuihan</footer><a class=entry-link aria-label="post link to Digest認証の仕組みをBashとJavaScriptで理解したい。" href=https://derbuihan.github.io/posts/digest_auth_bash_js/></a></article><article class=post-entry><header class=entry-header><h2>PyTorchの自動微分を使った1次元のイジング模型の分配関数の計算</h2></header><div class=entry-content><p>1 次元のイジング模型 周期的境界条件のもとで 1 次元のイジング模型のハミルトニアンは
$$ H\left(\sigma_{1}, \cdots, \sigma_{N} \right) = -J \sum_{i} \sigma_{i} \sigma_{i+1} - h \sum_{i} \sigma_{i} $$
である。 ここで、$\sigma_{i}=\pm 1$はスピンを表し、周期的境界条件から$\sigma_{1} = \sigma_{N+1}$が成り立つ。 また$h$は外部磁場を表し、$J$は隣り合うスピンの相互作用を表す。
このハミルトニアン$H$から分配関数$Z$は
$$ Z = \sum_{\sigma_{1}, \cdots, \sigma_{N} = \pm 1} e^{- \beta H \left(\sigma_{1}, \cdots, \sigma_{N} \right)} $$
と計算出来る。 ここで、$\beta = \frac{1}{k_B T}$は逆温度である。 この分配関数は次のように書き換えることが出来る。
$$ Z = \sum_{\sigma_{1}, \cdots, \sigma_{N}} \exp{\left( \sum_i \beta J \sigma_i \sigma_{i+1} + \frac{\beta h}{2} (\sigma_i + \sigma_{i+1}) \right)} = \mathrm{tr} \left( T^N \right) $$...</p></div><footer class=entry-footer><span title='2022-06-03 21:43:29 +0900 JST'>June 3, 2022</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;434 words&nbsp;·&nbsp;derbuihan</footer><a class=entry-link aria-label="post link to PyTorchの自動微分を使った1次元のイジング模型の分配関数の計算" href=https://derbuihan.github.io/posts/pytorch_1d_ising/></a></article><article class=post-entry><header class=entry-header><h2>充足可能性問題の相転移の実験</h2></header><div class=entry-content><p>充足可能性問題 (satisfiability problem, SAT) 「与えられた論理式を真にする真偽値$x_1, x_2 \dots$が存在するか？」という問題を充足可能性問題という。
この問題の最も一般的な形は、NP 完全であることが知られている。
例: $(x_1 \lor x_2) \land (x_1 \lor \bar{x_2}) \land (\bar{x_1} \lor \bar{x_2})$
解: $x_1=\text{True}$, $x_2=\text{False}$
この例のように$\bigwedge_i \bigvee_j x_{i,j}$で表される論理式を連言標準形といい、その各項の変数の数が 2 以下であるとき 2-SAT と呼ばれる。 2-SAT は多項式時間で解けるアルゴリズムが存在する。 一方で項の変数の数が 3 以下の 3-SAT は NP 完全であることが知られている。
問題の生成 3-SAT 問題は DIMACS CNF で記述される。
c example DIMACS-CNF 3-SAT p cnf 3 5 -1 -2 -3 0 1 -2 3 0 1 2 -3 0 1 -2 -3 0 -1 2 3 0 行頭がcの行はコメントである。 行頭がpの行には変数が 3 つで項数が 5 項である。 また、 -1 -2 -3 0は$\bar{x_1} \lor \bar{x_2} \lor \bar{x_3}$を示している。...</p></div><footer class=entry-footer><span title='2022-05-23 17:02:35 +0900 JST'>May 23, 2022</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;503 words&nbsp;·&nbsp;derbuihan</footer><a class=entry-link aria-label="post link to 充足可能性問題の相転移の実験" href=https://derbuihan.github.io/posts/minisat_phase_transition/></a></article><footer class=page-footer><nav class=pagination><a class=next href=https://derbuihan.github.io/page/2/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2023 <a href=https://derbuihan.github.io/>derbuihan blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>